zmodload -i zsh/parameter || return 1

prompt_mavam_help()
{
  print TODO
}

# Indicates whether we should update (potentially stale) VCS info.
# 
PROMPT_MAVAM_GIT_UPDATE=1

# Called before command excution. 
# Updates the git prompt if the command involved the word 'git'.
function prompt_mavam_preexec 
{
  typeset -gi PROMPT_MAVAM_START=SECONDS
  case "$(history $HISTCMD)" in 
    *git*)
      PROMPT_MAVAM_GIT_UPDATE=1
      ;;
  esac
}

# Called after directory change.
# If we change a directory, we have to recompute the git prompt.
function prompt_mavam_chpwd 
{
  PROMPT_MAVAM_GIT_UPDATE=1
}

prompt_mavam_precmd()
{
  setopt localoptions noxtrace noksharrays unset

  # Update the git prompt if needed
  if [[ -n "$PROMPT_MAVAM_GIT_UPDATE" ]] ; then
    vcs_info 'prompt'
    PROMPT_MAVAM_GIT_UPDATE=
  fi

  # Compute the real size of the git info widget.
  local zero='(%([BSUbfksu]|[FB]{*})|$(fg|ch)\[*[a-z]\])'
  local -i width2=${#${(S%%)${vcs_info_msg_0_}//$~zero/}}

  # Compute the widths of the remaining widgets we have in the top line.
  local -i width1=${#${(%%)psvar[1]}}
  local -i width3=${#${(%%)psvar[3]}}

  # Penalize long paths so that truncation does not always occur.
  ((width1 > 50)) && ((width1 = 50))

  # Now compute the fill width.
  # We always subtract the constant value 5 because the top row has two framing
  # characters on both ends, plus we leave a space on the very right side.
  local -i fill
  ((fill = COLUMNS - 5 - (width1 + width2 + width3)))
  # If the fill is negative, we first get rid of the VCS info.
  if ((fill < 0)) ; then
    ((fill += width2))
    ((width2 = 1))
  fi
  # If that's not enough, the hostname goes.
  if ((fill < 0)) ; then
    ((fill += width3))
    ((width3 = 1))
  fi
  # If that still doesn't suffice, then we need to work with the path as well.
  if ((fill < 0)) ; then
    ((width1 += fill))
    ((fill = 0))
  fi

  ((width1 -= 2))  # Subtract 2 for the surrounding parentheses
  psvar[4]=$width1
  psvar[5]=$width2
  psvar[6]=$width3
  psvar[7]=$fill
  ((psvar[9] = SECONDS - PROMPT_MAVAM_START))

  # Reset the timer.
  typeset -gi PROMPT_MAVAM_START=SECONDS
}

prompt_mavam_ps1()
{
  setopt localoptions noxtrace noksharrays promptsubst

  # The corresponding precmd function uses these values for length computation.
  psvar[1]="(%~)"
  psvar[3]="(%(!.%m.%n@%m))"

  # Assemble the left prompt.
  local -ah prompt
  prompt=(
    # Upper left corner.
    "$fg[frame]"
    '$ch[charset]$ch[on]$ch[ul]$ch[hbar]$ch[off]'
    # Add the current directory.
    "(%B$fg[widget]%\$[psvar[4]]<..<%~%<<$fg[reset]$fg[frame])"
    # Set the fill bar in the middle, consisting of psvar[7] characters.
    '$ch[on]'
    "\${(l.\$psvar[7]..$ch[hbar].)}"
    '$ch[off]'
    # If we're in a version-controlled directory, display its info.
    "%\$[psvar[5]]>>"
    '$vcs_info_msg_0_'
    "%<<"
    # user@host string.
    "%\$[psvar[6]]>>"
    "$fg[frame]("
    "$fg[widget]%(!.%m.%n$fg[indicator]@$fg[widget]%m)$fg[reset]"
    "$fg[frame])"
    "%<<"
    # Upper right and lower left corner, separated by a linebreak.
    '$ch[on]$ch[hbar]$ch[ur]$ch[off]'
    $'\n'
    '$ch[on]$ch[ll]$ch[hbar]$ch[off]'
    # Prompt indicator.
    "($fg[indicator]%#$fg[frame])$fg[reset] "
    )
  PROMPT="${(j::)prompt}"

  # Assemble the right prompt.
  local -ah rprompt
  local -h ec
  ec="%(?.%{$fg[green]%}.%{$fg[red]%})%?$fg[reset]"
  rprompt=(
    # Timing and status code.
    "$fg[frame]($fg[widget]" '$psvar[9]' "s$fg[reset] $ch[arrow] $ec$fg[frame])"
    # Date and time.
    "($fg[widget]%D{%H:%M:%S %y-%m-%d}$fg[frame])"
    # Bottom right corner.
    '$ch[on]$ch[hbar]$ch[lr]$ch[off]'
    "$fg[reset]"
    )
  RPROMPT="${(j::)rprompt}"
}

prompt_mavam_setup()
{
  setopt localoptions nolocaltraps noksharrays unset
	prompt_opts=( cr subst percent )

  local use_altchar=yes
  local -A colors
  repeat 1 case "$1:l" in
    (off|disable)
      add-zsh-hook -D precmd "prompt_mavam_precmd"
      add-zsh-hook -D preexec "prompt_mavam_preexec"
      add-zsh-hook -D chpwd "prompt_mavam_chpwd"
      PROMPT="%n@%m %# "
      unset RPROMPT
      return 1
      ;;
	  (-a|noaltchar)
      shift
      use_altchar='no'
      ;;
    (*)
      ;;
  esac

  # Setup colors. We reuse the fg color map.
  if [[ $UID == "0" ]] ; then
    fg[frame]="%F{${1:-red}}"
  elif [[ -n "$SSH_CONNECTION" ]]; then
    fg[frame]="%F{${1:-blue}}"
  else
    fg[frame]="%F{${1:-cyan}}"
  fi
  if [[ -z "$SSH_CONNECTION" ]]; then
    fg[indicator]="%F{${2:-green}}"   # Local
  else
    fg[indicator]="%F{${2:-magenta}}" # Remote
  fi
  fg[widget]="%F{${3:-cyan}}"
  fg[text]="%F{${4:-yellow}}"
  fg[reset]="%f%k%u%b"

  # Setup the map with special characters we use in the prompt.
  local -Ah altchar
  set -A altchar ${(s..)terminfo[acsc]}
  typeset -gA ch
	if [[ "$use_altchar" == "yes" ]] ; then
    ch[charset]="%{$terminfo[enacs]%}"
    ch[on]="%{$terminfo[smacs]%}"
    ch[off]="%{$terminfo[rmacs]%}"
    ch[hbar]=${altchar[q]:--}
    ch[ul]=${altchar[l]:--}
    ch[ll]=${altchar[m]:--}
    ch[lr]=${altchar[j]:--}
    ch[ur]=${altchar[k]:--}
    # FIXME: Use altchar character as opposed to UTF-8.
    ch[circle]="●"
    ch[arrow]="→"
	else
    ch[charset]=""
    ch[on]=""
    ch[off]=""
    ch[hbar]="-"
    ch[ul]="+"
    ch[ll]="+"
    ch[lr]="+"
    ch[ur]="+"
    ch[circle]="*"
    ch[arrow]="->"
	fi

  # VCS styling
  # %s   The VCS in use (git, hg, svn, etc.).
  # %b   Information about the current branch.
  # %a   An  identifier  that  describes  the action. Only makes sense in
  #      actionformats.
  # %i   The current revision number or identifier. For hg the  hgrevfor-
  #      mat style may be used to customize the output.
  # %c   The  string from the stagedstr style if there are staged changes
  #      in the repository.
  # %u   The string from the unstagedstr  style  if  there  are  unstaged
  #      changes in the repository.
  # %R   The base directory of the repository.
  # %r   The repository name. If %R is /foo/bar/repoXY, %r is repoXY.
  # %S   A    subdirectory    within    a    repository.   If   $PWD   is
  #      /foo/bar/repoXY/beer/tasty, %S is beer/tasty.
  # %m   A "misc" replacement. It is at the discretion of the backend  to
  #      decide what this replacement expands to. It is currently used by
  #      the hg and git backends to display patch information from the mq
  #      and stgit extensions.

  # Note that we add the surrounding parenthesis to the format string to
  # facilitate truncation when we're not inside a directory with a git repo.
  local fmt_branch="$fg[frame]($fg[text]%b%u%c$fg[frame])"
  local fmt_action="${branch}-%F{red}%a"
  zstyle ':vcs_info:*:prompt:*' enable git svn hg
  zstyle ':vcs_info:*:prompt:*' check-for-changes true    # Expensive!
  zstyle ':vcs_info:*:prompt:*' stagedstr     "%F{green}$ch[circle]"
  zstyle ':vcs_info:*:prompt:*' unstagedstr   "%F{red}$ch[circle]"
  zstyle ':vcs_info:*:prompt:*' actionformats "${fmt_action}"
  zstyle ':vcs_info:*:prompt:*' formats       "${fmt_branch}"
  zstyle ':vcs_info:*:prompt:*' nvcsformats   ""
  #zstyle ':vcs_info:*:prompt:*' branchformat "%b$fg[frame]:%F{yellow}%r"

  # PS2 (used in loops, statements, ...)
  PS2="%(4_:... :)%3_ $fg[frame]>$fg[reset] "

  # Correction prompt
  SPROMPT="zsh: correct '%B%R%b' to '%B%r%b'? (%Un%uo|%Uy%ues|%Ua%ubort|%Ue%udit) "

  # No RPS1 by default because prompt_off_setup doesn't fix it.
  (($#RPS1 && $# > 4)) && RPS1="%F{$5}$RPS1%f"

  prompt_mavam_ps1

  add-zsh-hook precmd prompt_mavam_precmd
  add-zsh-hook preexec prompt_mavam_preexec
  add-zsh-hook chpwd prompt_mavam_chpwd

  return 0
}

prompt_mavam_preview()
{
  prompt_preview_theme mavam "$@"
}

[[ -o kshautoload ]] || prompt_mavam_setup "$@"

# vim:ft=zsh
